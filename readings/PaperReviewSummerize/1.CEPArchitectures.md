#Complex event processing system
##Background
This report is to summarize different complex event processing system with a focus on their different features.
##Non-deterministic Finite automata(NFA)
NFA is the most common used method for evaluating CEP queries.

![NFA](figure\NFA.jpg)

###1. SASE (Diao Yan Lei, UMASS)

1. [High-Performance Complex Event Processing over Streams] sigmod'06 #cite:[603]
2. [Recognizing patterns in stream with imprecise timestamps] vldb'10
3. [SASE: Complex Event Processing over Streams] CIDR'07
4. [Optimizing Expensive Queries in Complex Event Processing] sigmod'14

The SASE system primary focus RFID industry. 

####1.1 Language features:

- **sequencing(SEQ)**:This is not *new*, idea come from "active database" community.
- **negation(!)**:Extends negation from active database to be more flexible to use in event sequence.
- **parameterization(WHERE):** This is used to distinguish with the simple predicates that compare to a constant. It adds feature to correlating events via value-based constraints.
- **windowing(WITHIN)**: sliding windows for imposing additional temporal constraints

####1.2 Query plan:
presented a query query plan-based approach to implementing this language, which uses native operators.
#####1.2.1 Native operators
- **Sequence scan and construction (SSC)**: SSC handles the *positive* components of SEQ, internally, SSC contains 
	- a sequence scan operator(SS->).
	- sequence construction operator(SC<-).
- **Negation(NG)**: NG handles the *negative* components of a SEQ, e.g. for SEQ(A,!B,C) this operators checkes if there's a 'b' event that arrived between the 'a' and 'c' event.
- **Window(WD)**:For *each event sequence*, it checks if the temporal difference between the first and lasts event is less than the specified window T. 
- **Selection(Ïƒ)**:works similar to relational query processing, but include *parameterized* ones.
#####1.2.2 Event sequence Matching
The author adopt NFA to represent the structure of an event sequence:
######Sequence Scan and Construction
For each **SSC** sub-sequence type, an NFA is created by mapping successive event types to successive NFA States. Like figure 2, state 0 is the starting state,state 1 is for successful recognition of an A event.. state, denoted using two concentric circles, is the accepting state of the NFA.

![NFA](figure\SSC.png)
		
Once an accepting state is reached during sequence scan, **sequence construction** is invoked to create the event sequences that the most recent event has completed.**Notice that**: This is actually because of the special feature of SASE: selection policy (i.e. contiguity/skip till next/skip till any).

The *solution* proposed by author is: Extract from the runtime stack a single-source DAG that starts at an instance of the accepting state in the rightmost cell of the stack and traverses back along the predecessor pointers until reaching instances of the starting state. Event sequence can then be generated by enumerating all possible paths from the source to the sinks of the DAG.

######Negation
NG handles the negative components of the SEQ construct in a query which have been ignored by SSC. For each input event sequence, NG performs two tasks for each negative component:

Task 1: Check if an event of the type specified in the negative component appeared in a specific time interval.

Task 2: If such an event exists, check if it satisfies all the relevant predicates.

Any event passes both will cause the sequence to *False*.

***Compile:Time interval for task (1)***

- SEQ(A,!B,C): Time interval is defined as (A.timestamp, C.timestamp);
- SEQ(!A,B):the window size T is used to set interval to be (B.timestamp - T, B.timestamp).
- SEQ(A,!B):Interval is set to(A.timestamp, A.timestamp+T), **in addition**, the negation operator is marked as "postponed by T", which indicates to the runtime system that the evaluation of each event sequences needs to be postponed by a period of length T after its arrival.

***Runtime system support***

In addition to the possible postponed evaluation, it provides indexing support, 
> i.e. given a time interval, retrieving all the events that occurred in the interval can be supported by using a standard relational indexing techniques.

The author proposed an advanced technique called *partitioned indexing*. the idea is to *partition an event stream by timestamp.*

####1.3 optimization for handling:
> A mechanism shared by all these optimizations is to index relevant events both in temporal order and across value-based partitions.

- large windows:
	- intra-operator optimization to expedite sequence scan and construction(SSC).
- reducing intermediate result size.
	- inter-operator optimization that strategically push predicates and windows down to SSC to reduce intermediate result sizes.

		![NFA](figure\ActiveInstanceStack.png)

######Sequence Scan
Instead of using a runtime stack to record the set of active states as an event arrives like Figure 2. 
An active *instance* stack is created at *each* NFA state to store the events that triggered transitions to this state like Figure 3.
In addition, each instance maintain its own *most Recent Instance Previous stack(RIP)*, which tells that any instances in the A stack up to a<sub>4</sub> (i.e. a<sub>1</sub> and a<sub>4</sub>)can be matched with b<sub>6</sub> if event sequences involving b<sub>6</sub> need to be created.
######Sequence Construction
With active instance stack, the consturction is imply done by a DFS in the DAG that is rooted at this instance and contains all the virtual edges reachable (RIP)
#####Pushing Predicates Down
![NFA](figure\PAIS.png)

######Pushing an equivalence test down to SSC
the idea is partition the data by the 'equivalent attribute', so for instance, d<sub>9</sub> does not need to go back and check for b<sub>3</sub>.
 
######Pushing multiple equivalence test down to SSC
![NFA](figure\multi-PAIS.png)

like in Figure 5,
we can partition again after partition.
#####Pushing Windows Down
Similarly, window constraint can also be evaluated early in SSC to reduce the number of event sequences created.
> detail are omitted by the author

- window in sequence scan can filter some of the events so they are not added to active instance stacks, and prunes expired instance from stacks.
- window in sequence construction searches those stacks and performs window checking on the fly for each event sequence to be generated.

####1.4 Recognizing Patterns in Streams with Imprecise Timestamps, vldb'10
The author addressed the pattern evaluation in event streams **with imprecise timestamps**. They presented a temporal uncertainty model for such events, formal semantics etc..
####1.5 Optimizing Expensive Queries in Complex Event Processing, sigmod'14
They first theoretically identify "What's the expensive queries in CEP", then they proposed several optimization strategy towards those expensive queries.
###2.Siddhi(Suhothayan, University of Sri Lanka)
1.	"Siddhi:A Second Look at Complex Event Processing Architectures" - GCE'11
>it's now become the core engine of a commercial product of WCO2.

The author try to improve the architecture of CEP system from four decision:

	- Multi-threading
	- Queues and use of pipelining
	- Nested queries and chaining streams
	- Query optimization and common sub-query elimination 
###3.Cayuga(Cornell University)
1. [Cayuga:A General Purpose Event Monitoring System], CIDR'07
2. [Massively Multi-Query Join Processing in Publish/Subscribe Systems], sigmod'07
3. [Cayuga: A High-Performance Event Processing Engine] (demo).SIGMOD 2007
4. [What is "Next" in Event Processing?], pods'07
5. [Towards Expressive Publish/Subscribe Systems],EDBT'06
6. [Processing High-Speed Intelligence Feeds in Real-Time], ISI'05
> the reserach 
Cayuga as a general-purpose Complex Event Processing system which can be used to detect event patterns in multiple unrelated event streams. 
> It allows high scalability since it was developed from publish-subscription techniques [claimed by author:The query processing engine extends the functionality of traditional publish/subscribe to support stateful subscriptions. ]
> it's system architecture also supports large number of concurrent subscriptions(pattern queries)
One of the most novel components of Cayuga is the implementation of its processing engine that utilizes a variation of NFA. 
##Non-NFA architecture
###1. Zstream(MIT)
1. *[zstream a cost-based query processor for adaptively detecting composite events]*, SIGMOD'09
2. 
This is so far the only one CEP engine does not follow NFA method, instead, they proposed **query-plan-tree* approach.

>author from SASE (in vldb'10) criticize ZStream:"It is further restricted to tree-structure query
plans (that is, the evaluation order has to obey the tree structure)."

They argue that:*"The previously proposed NFA-based approaches have three limitations that we seek to address:"*

1. Fixed Order of Evaluation

> NFA's naturally express patterns as a series of state transitions. Hence current NFA-based approaches impose a **Fixed Evaluation order**.
> 
> Through it might be possible to build different NFA's, or multiple sub-NFA's, to evaluate a given query in a different order, but non-work explored this possibility.

2. Negation.
> It's not straightforward to efficiently model negation (events that do not occur) in an NFA when there exist **predicates between the negated and non-negated events.**
> As a result, existing NFA-system perform negation as a post-NFA filtering step (e.g. SASE)

3. Concurrent Events.
> As with negation, it's also hard to support concurrent events (e.g. A and B), in an NFA-based model because NFA's explicitly order state transitions.

Zstream addresses the above limitations of previously proposed approaches, including the following key features:
1. tree-based query plan structure for CEP queries that are amenable to a variety of algebraic optimizations.
2. defined a notion of an *optimal plan* and show that ZStream can effectively search the space of possible plans that correspond to a specified sequential pattern.
3. able to unify the evaluation of sequence, conjunction, and disjunction as variants of the **join** operator and also enables flexible operator ordering.
4. formulation of **negation** queries so they can be incorporated into this tree-based model just like other operators, rather than being applied as a final filtration step(like in NFA-based)
5. can adaptively change the evaluation plan as queries run and that an adaptive plan can outperform a static plan significantly when characteristics of incoming streams change(e.g. event rates or selectivity).

> claimed by author:"The goal is not to demonstrate that an NFA-based approach is inherently inferior to a tree-based query-plan approach, but to show that:
	1. by carefully designing the underlying infrastructure and algorithm, a tree-based approach can process most CEP queries very efficiently,
	2. without some notion of an optimal plan, as well as statistics and a cost model to estimate that optimal plan, any approach that uses a fixed evaluation order (whether based on NFA's or trees) is suboptimal. 
The idea is like below:
![NFA](figure\zstream.png).

##my comments:
there's only one query-plan-tree style for CEP, and all the rest (later proposed) are all follows NFA-based, what's the deeper reason for that?is tree-based fundamentally wrong? But obviously, tree-based have the potential to enjoy many ideas to perform query optimization from traditional database research (also query-tree plan based)

>will it be a research point to again try query-plan-tree based CEP ? Follow the idea of query plan tree, the first thing Zstream doesnot have is *Multi-query optimization*.

>another research point might be, to investigate which architecture (NFA, tree) is better in what situation. When this is done, then we can think of how to adaptively use different architecture at the same time (Distribute engine in one box, idea from Eurosys'11).